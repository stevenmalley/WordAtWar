import { createSlice } from '@reduxjs/toolkit';


/**
 * 
 * Tiles on the board and in the active (client) player's supply
 * 
 * tile: {
 *   id: <int>,
 *   letter: <char> | null,
 *   score: <int>,
 *   location: "board" | "player",
 *   position: {row,col} | <int>, // {row,col} if location is "board", <int> indicating order in the display if location is "player"
 *   selected: <bool>,
 *   blankLetter: <char> | null, // if 'letter' is null, this property receives the letter chosen for the blank to act as
 * }
 * 
 */

export const tileSlice = createSlice({
  name: 'tiles',
  initialState: [],
  reducers: {
    loadTiles:(tiles,action) => action.payload,
    selectTile:(tiles,action) => {
      // toggle the clicked tile and deselect all other tiles
      //tiles.forEach(tile => tile.selected = (tile.id === action.payload && !tile.locked) ? !tile.selected : false);
      const selectedTile = tiles.find(tile => tile.id === action.payload);
      tiles.forEach(tile => {
        if (tile.id !== action.payload) {
          tile.selected = false;
          if (tile.location !== "board" && tile.position > selectedTile.position) tile.position--;
        }
      });
      selectedTile.selected = true;
      selectedTile.location = "selected";
      selectedTile.position = null;
    },
    deselectTiles:(tiles,action) => {
      tiles.forEach(tile => tile.selected = false);
    },
    placeTile:(tiles,action) => {
      const tile = tiles.find(tile => tile.id === action.payload.tileID); // should be the selected tile
      if (tile) {
        tile.location = "board";
        tile.position = action.payload.position;
        tile.selected = false;
      }
    },
    returnTile:(tiles,action) => {
      // a click on the 'player tiles' section returns a selected tile from the board, or moves a selected tile in the player tiles section to the right
      const tile = tiles.find(tile => tile.id === action.payload.tileID); // should be the selected tile
      tiles.forEach(t => {
        if (t.id !== action.payload.tileID) {
          t.position = (t.location !== "board" && t.position > action.payload.position) ? t.position+1 : t.position; // drop the tiles with higher positions down when moving tiles around within the player tile section
        }
      });
      tile.location = action.payload.playerID;
      tile.position = action.payload.position+1;
      tile.selected = false;
    },
    returnAllTiles:(tiles,action) => {
      const playerTilesOffBoard = tiles.filter(tile => tile.location !== "board");
      const playerTilesOnBoard = tiles.filter(tile => tile.location === "board" && !tile.locked);
      playerTilesOffBoard.sort((a,b) => a.position - b.position);
      playerTilesOnBoard.sort((a,b) => a.position - b.position);
      playerTilesOffBoard.concat(playerTilesOnBoard).forEach((tile,i) => {
        tile.location = action.payload.playerID;
        tile.position = i;
        tile.blankLetter = null;
      });
    },
    blankChoice:(tiles,action) => {
      tiles.find(tile => tile.id === action.payload.blankID).blankLetter = action.payload.letter;
    },
    clearBlankChoice:(tiles,action) => {
      tiles.find(tile => tile.id === action.payload).blankLetter = null;
    },
    toggleSwap:(tiles,action) => {
      const toggledTile = tiles.find(tile => tile.id === action.payload);
      toggledTile.swapping = !toggledTile.swapping;
    },
    updatePlayerTiles:(tiles,action) => tiles.filter(tile => tile.location != action.payload.playerID).concat(action.payload.tiles),
    cancelSwaps:(tiles,action) => {
      tiles.forEach(tile => tile.swapping = false);
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  // extraReducers: (builder) => {
  //   builder
  //     .addCase(incrementAsync.pending, (state) => {
  //       state.status = 'loading';
  //     })
  //     .addCase(incrementAsync.fulfilled, (state, action) => {
  //       state.status = 'idle';
  //       state.value += action.payload;
  //     });
  // },
});




export const selectTiles = (state) => state.tiles;




export const loadTiles = (tiles) => {
  return async (dispatch, getState) => {
    dispatch({type: 'tiles/loadTiles', payload: tiles});
  }
};

export const selectTile = (tileID) => {
  return (dispatch, getState) => {
    dispatch({type: 'tiles/selectTile', payload: tileID});
  }
};

export const deselectTiles = () => {
  return (dispatch, getState) => {
    dispatch({type: 'tiles/deselectTiles', payload: null});
  }
};

export const placeTile = (tileID,position) => {
  return (dispatch, getState) => {
    dispatch({type: 'tiles/placeTile', payload: {tileID,position}});
  }
};

export const returnTile = (playerID,tileID,position) => {
  return (dispatch, getState) => {
    dispatch({type: 'tiles/returnTile', payload: {playerID,tileID,position}});
  }
};

export const returnAllTiles = (playerID) => {
  return (dispatch, getState) => {
    dispatch({type: 'tiles/returnAllTiles', payload: {playerID}});
  }
};

export const blankChoice = (blankID,letter) => {
  return async (dispatch, getState) => {
    dispatch({type: 'tiles/blankChoice', payload: {blankID,letter}});
  }
};

export const clearBlankChoice = (blankID) => {
  return async (dispatch, getState) => {
    dispatch({type: 'tiles/clearBlankChoice', payload: blankID});
  }
};

export const toggleSwap = (tileID) => {
  return (dispatch, getState) => {
    dispatch({type: 'tiles/toggleSwap', payload: tileID});
  }
};

export const updatePlayerTiles = (tiles,playerID) => {
  return async (dispatch, getState) => {
    dispatch({type: 'tiles/updatePlayerTiles', payload: {tiles,playerID}});
  }
};

export const cancelSwaps = () => {
  return (dispatch, getState) => {
    dispatch({type: 'tiles/cancelSwaps', payload: null});
  }
};