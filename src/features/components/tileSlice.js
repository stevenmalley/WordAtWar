import { createSlice } from '@reduxjs/toolkit';
import { fetchTileData, drawTiles } from './vocabbleAPI';


/**
 * 
 * Tiles on the board and in the active (client) player's supply
 * 
 * tile: {
 *   id: <int>,
 *   letter: <char> | null,
 *   score: <int>,
 *   location: "board" | "player",
 *   position: {row,col} | <int>, // {row,col} if location is "board", <int> indicating order in the display if location is "player"
 *   selected: <bool>
 * }
 * 
 */

export const tileSlice = createSlice({
  name: 'tiles',
  initialState: [],
  reducers: {
    getTiles:(tiles,action) => action.payload,
    loadTiles:(tiles,action) => action.payload,
    selectTile:(tiles,action) => {
      // toggle the clicked tile and deselect all other tiles
      console.log("st",action);
      tiles.forEach(tile => tile.selected = (tile.id === action.payload && !tile.locked) ? !tile.selected : false);
    },
    deselectTiles:(tiles,action) => {
      tiles.forEach(tile => tile.selected = false);
    },
    placeTile:(tiles,action) => {
      const tile = tiles.find(tile => tile.id === action.payload.tileID); // should be the selected tile
      tiles.forEach(t => t.position = (t.location !== "board" && t.position > tile.position) ? t.position-1 : t.position); // drop the tiles with higher positions down
      if (tile) {
        tile.location = "board";
        tile.position = action.payload.position;
      }
    },
    returnTile:(tiles,action) => {
      // a click on the 'player tiles' section returns a selected tile from the board, or moves a selected tile in the player tiles section to the right
      const tile = tiles.find(tile => tile.id === action.payload.tileID); // should be the selected tile
      if (tile.location !== "board") tiles.forEach(t => {
        t.position = (t.location !== "board" && t.position > tile.position) ? t.position-1 : t.position; // drop the tiles with higher positions down when moving tiles around within the player tile section
      });
      if (tile) {
        tile.location = action.payload.playerID;
        tile.position = tiles.filter(t => t.location === action.payload.playerID).length;
        tile.selected = false;
      }
    },
    addTiles:(tiles,action) => {
      action.payload.forEach(newTile => tiles.push(newTile));
    },
    submit:(tiles,action) => {

    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  // extraReducers: (builder) => {
  //   builder
  //     .addCase(incrementAsync.pending, (state) => {
  //       state.status = 'loading';
  //     })
  //     .addCase(incrementAsync.fulfilled, (state, action) => {
  //       state.status = 'idle';
  //       state.value += action.payload;
  //     });
  // },
});




export const selectTiles = (state) => state.tiles;





export const getTiles = () => {
  return async (dispatch, getState) => {
    const response = await fetchTileData(5,2); // gameID, playerID
    dispatch({type: 'tiles/getTiles', payload: response});
  }
};

export const loadTiles = (tiles) => {
  return async (dispatch, getState) => {
    dispatch({type: 'tiles/loadTiles', payload: tiles});
  }
};

export const selectTile = (tileID) => {
  return (dispatch, getState) => {
    dispatch({type: 'tiles/selectTile', payload: tileID});
  }
};

export const deselectTiles = () => {
  return (dispatch, getState) => {
    dispatch({type: 'tiles/deselectTiles', payload: null});
  }
};

export const placeTile = (tileID,position) => {
  return (dispatch, getState) => {
    dispatch({type: 'tiles/placeTile', payload: {tileID,position}});
  }
};

export const returnTile = (playerID,tileID) => {
  return (dispatch, getState) => {
    dispatch({type: 'tiles/returnTile', payload: {playerID,tileID}});
  }
}

export const addTiles = () => {
  // async function retrieving new tiles from the API
  return async (dispatch, getState) => {
    const response = await drawTiles(5,2); // gameID, playerID
    dispatch({type: 'tiles/addTiles', payload: response});
  }
}

export const submit = (playerID, gameID, tiles) => {
  // async function sending placed tiles to the server to check for legality
  return async (dispatch, getState) => {
    dispatch({type: 'tiles/submit', payload: null});
  }
}