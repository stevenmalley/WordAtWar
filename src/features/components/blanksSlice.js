import { createSlice } from '@reduxjs/toolkit';


/**
 * 
 * [ {id, position, letter}, ... ]
 * 
 * ID, position and chosen letter for non-locked blanks that have been placed on the board.
 * 
 * position is saved when a BoardSpace is selected to place a blank tile, so that it is saved for when BlankTileChoice is used.
 * 
 * letter is saved so BoardSpace can display the letter and GameControls can submit the data to the server.
 * 
 * 
 * Whenever a blank has a position but no letter, BlankTileChoice should be displayed to allow a letter to be chosen
 * 
 * 
 * NB the server does not record this data, it only keeps the standard tile data and, when on the board, its 'letter' property is replaced by the chosen letter
 * 
 * 
 */

export const blanksSlice = createSlice({
  name: 'blanks',
  initialState: [],
  reducers: {
    placeBlank:(blanks,action) => {
      const previousPlacement = blanks.find(blank => blank.id === action.payload.blankID);
      if (previousPlacement) {
        previousPlacement.position = action.payload.position;
        previousPlacement.letter = null;
      }
      else blanks.push({id:action.payload.blankID, position:action.payload.position, letter:null});
    },
    chooseLetter:(blanks,action) => {
      blanks.find(blank => blank.id === action.payload.blankID).letter = action.payload.letter;
    },
    clearBlankChoice:(blanks,action) => blanks.filter(blank => blank.id !== action.payload),
    clearBlanks:(blanks,action) => []
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  // extraReducers: (builder) => {
  //   builder
  //     .addCase(incrementAsync.pending, (state) => {
  //       state.status = 'loading';
  //     })
  //     .addCase(incrementAsync.fulfilled, (state, action) => {
  //       state.status = 'idle';
  //       state.value += action.payload;
  //     });
  // },
});




export const selectBlanks = (state) => state.blanks;




export const placeBlank = (blankID,position) => {
  return async (dispatch, getState) => {
    dispatch({type: 'blanks/placeBlank', payload: {blankID,position}});
  }
};

export const chooseLetter = (blankID,letter) => {
  return async (dispatch, getState) => {
    dispatch({type: 'blanks/chooseLetter', payload: {blankID,letter}});
  }
};

export const clearBlankChoice = (blankID) => {
  return async (dispatch, getState) => {
    dispatch({type: 'blanks/clearBlankChoice', payload: blankID});
  }
};

export const clearBlanks = () => {
  return async (dispatch, getState) => {
    dispatch({type: 'blanks/clearBlanks', payload: null});
  }
};